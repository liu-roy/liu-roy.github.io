---
title: 深入理解java虚拟机
date: 2017-09-01 15:53:24
categories: jvm
tags: 读书笔记
---
---
[TOC]

---
# 深入理解java虚拟机读书笔记

## 序
基于此书第二版，会加上自己的一些理解，如有错误，望指出
 
## 第1章 走近java 
主要介绍了java的技术体系，java发展史，java虚拟机发展史和java未来
<!--more-->
## 第2章 java内存区域与内存溢出一场
### 运行时数据区域
![这里写图片描述](http://img.blog.csdn.net/20170903132032524)
#### 程序计数器
记录当前线程执行字节码的行号
- 每个线程拥有一个
- jvm规范中唯一一个没有定义OutOfMemoryError情况的区域

#### java虚拟机栈
- java代码调用才有的，俗称栈帧
- 线程私有
- 存储局部变量表 操作数栈 动态链接 方法出口
- 局部变量表所需要的内存空间在编译期间完成分配。
- 两种异常：
如果线程请求的栈的深度大于虚拟机所允许的深度抛，出“StackOverflowError”。
如果虚拟机栈可以动态扩展（大多数虚拟机都支持），扩展时无法申请
到足够的内存，抛出“OutOfMemoryError”。

#### 本地方法栈
同java虚拟机栈，只不过是针对为虚拟机执行Native方法服务。

#### java堆
是所有线程共享的一块内存，也是虚拟机所需要管理的内存（GC）最大的一块, 用来存储对象实例和数组，，不连续，可扩展，会抛出OutOfMemoryError,指令-xmx xms。
粗略分区：
- 新生代
- 老年代

细分区:
- Eden
- From Survivor
- To Survivor 

#### 方法区
- 线程共享
- 存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码
- 可以选择不进行垃圾回收
- 不连续，可扩展，会抛出OutOfMemoryError。

#### 运行时常量池
属于方法区的一部分，用于存放编译期生成的各种字面量和符号引用
- 具备动态性：并不是预置Class文件中的常量池的内容才能进入方法运行时常量；运行时也可以将新的常量放入池中。如String的intern()方法。
- OutOfMemeoryError

#### 直接内存
不是虚拟机运行时数据区的一部分
NIO利用 原生Navtive函数直接分配堆外内存，避免java堆和Native堆来回进行数据复制，也会产生OutOfMemoryError

### HotSpot虚拟机对象探秘
#### 对象的创建
（第七章详细介绍）

#### 对象的内存布局
对象在内存中存储的布局
- 对象头
- 实例数据
- 对齐填充

对象头
- mark word
存储对象自身的运行时数据，如：HashCode、GC分代年龄、锁状态、线程持有的锁、偏向线程id、偏向时间戳等。

- 类型指针：对象指向它的类元素的指针。
通过这个指针找到这个对象是哪个类的实例
不是所有jvm在对象数据上保留类型指针，查找对象不一定经过对象本身（如果是java数组，对象头部还会记录数组长度的数据）。

实例数据
对象真正存储的有效信息。也是在程序中所定义的各种类型的字段内容。
这部分定义会受到jvm分配策略参数和字段在java源码中定义的顺序的影响。

对齐填充
仅是占位符的作用。

### 对象的访问定位
通过站上的reference数据来操作堆上的具体对象
不同的虚拟机有不同的访问凡是主流的的访问方式有句柄和指针两种
1. 通过句柄访问对象
- 堆中划出句柄池保留对象指针，java栈存储句柄池地址
- 二次索引，速度慢，但是对象移动无需改变reference，只需改变句柄池
![通过句柄访问对象](http://img.blog.csdn.net/20170903140315366?)
2. 通过直接指针访问对象（HotSpot）
![直接指针访问对象](http://img.blog.csdn.net/20170903140444639?)
- reference 保存的是对象地址，对象中包含对象类型数据的指针
- 速度快，少了一次指针定位

## 实战：OutOfMemoryError异常
略
